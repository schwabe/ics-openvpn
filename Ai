import tensorflow as tf
from tensorflow.keras import layers, models

# Load and preprocess data (e.g., MNIST)
mnist = tf.keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / 255.0, x_test / 255.0
# Build model
model = models.Sequential([
    layers.Flatten(input_shape=(28, 28)),
    layers.Dense(128, activation='relu'),
    layers.Dropout(0.2),
    layers.Dense(10)
])
# Compile and train
model.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])
model.fit(x_train, y_train, epochs=5)
model.evaluate(x_test, y_test)
from transformers import pipeline
generator = pipeline("text-generation", model="gpt2")
result = generator("Once upon a time", max_length=50, num_return_sequences=1)
print(result[0]['generated_text'])
from diffusers import StableDiffusionPipeline
import torch
pipe = StableDiffusionPipeline.from_pretrained("CompVis/stable-diffusion-v1-4", torch_dtype=torch.float16)
pipe.to("cuda")
image = pipe("a futuristic city at sunset").images[0]
image.show()
# Example using Magentaâ€™s Melody RNN
# Install: pip install magenta
from magenta.models.melody_rnn import melody_rnn_sequence_generator
# Setup omitted for brevity, but I can give you a full setup guide.
# This can generate MIDI music from a seed melody.from transformers import pipeline
# Load a model fine-tuned for code understanding
code_explainer = pipeline("text2text-generation", model="Salesforce/codet5-base")
code = """def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True"""
prompt = f"Explain this code:\n{code}"
explanation = code_explainer(prompt, max_length=128)[0]['generated_text']
print(explanation)import astfrom multiprocessing import Pool
code = """
def add(a, b):
    return a + b
"""
tree = ast.parse(code)
for node in ast.walk(tree):
    if isinstance(node, ast.FunctionDef):
        print(f"Function: {node.name} has {len(node.args.args)} arguments")# Simple computation: solving a quadratic equation ax^2 + bx + c = 0
import math
def solve_quadratic(a, b, c):
    discriminant = b**2 - 4*a*c
    if discriminant < 0:
        return "No real roots"
    root1 = (-b + math.sqrt(discriminant)) / (2*a)
    root2 = (-b - math.sqrt(discriminant)) / (2*a)
    return root1, root2
print(solve_quadratic(1, -3, 2))  # Outputs: (2.0, 1.0)
from multiprocessing import Pool

def square(x):
    return x * x

if __name__ == "__main__":
    with Pool(4) as p:
        results = p.map(square, range(1000000))
        print(results[:10])import cupy as cp

x = cp.arange(1e6).reshape(1000, 1000)
y = cp.sin(x) + cp.log(x)
print(y)from scipy.integrate import solve_ivp
import numpy as np
import matplotlib.pyplot as plt

def model(t, y):
    return -0.5 * y

sol = solve_ivp(model, [0, 10], [5], t_eval=np.linspace(0, 10, 100))
plt.plot(sol.t, sol.y[0])
plt.title("Exponential Decay")
plt.show()from qiskit import QuantumCircuit, Aer, execute

qc = QuantumCircuit(1, 1)
qc.h(0)  # Hadamard gate
qc.measure(0, 0)

backend = Aer.get_backend('qasm_simulator')
result = execute(qc, backend, shots=1000).result()
counts = result.get_counts()

print(counts)import socket

def scan_ports(target, ports):
    print(f"Scanning {target}...")
    for port in ports:
        try:
            s = socket.socket()
            s.settimeout(0.5)
            s.connect((target, port))
            print(f"[+] Port {port} is open")
            s.close()
        except:
            pass

scan_ports("127.0.0.1", range(1, 100))import socket
import threading
from queue import Queue

# Set target and port range
target = '127.0.0.1'
port_range = range(1, 1025)
thread_count = 100
q = Queue()

# Thread worker
def scan():
    while not q.empty():
        port = q.get()
        try:
            s = socket.socket()
            s.settimeout(0.5)
            s.connect((target, port))
            try:
                banner = s.recv(1024).decode().strip()
            except:
                banner = "No banner"
            print(f"[+] Port {port} is open: {banner}")
            s.close()
        except:
            pass
        q.task_done()

# Fill the queue
for port in port_range:
    q.put(port)

# Start threads
for _ in range(thread_count):
    t = threading.Thread(target=scan)
    t.daemon = True
    t.start()

q.join()
